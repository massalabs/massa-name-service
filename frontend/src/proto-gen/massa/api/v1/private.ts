// @generated by protobuf-ts 2.9.1 with parameter generate_dependencies
// @generated from protobuf file "massa/api/v1/private.proto" (package "massa.api.v1", syntax proto3)
// tslint:disable
//
// Copyright (c) 2023 MASSA LABS <info@massa.net>
//
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MESSAGE_TYPE } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { NodeStatus } from '../../model/v1/node';
import { MipStatusEntry } from '../../model/v1/versioning';
/**
 * AddToBootstrapBlacklistRequest holds the request for AddToBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.AddToBootstrapBlacklistRequest
 */
export interface AddToBootstrapBlacklistRequest {
  /**
   * IP addresses to add to bootstrap blacklist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * AddToBootstrapBlacklistResponse holds the response from AddToBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.AddToBootstrapBlacklistResponse
 */
export interface AddToBootstrapBlacklistResponse {}
/**
 * AddToBootstrapWhitelistRequest holds the request for AddToBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.AddToBootstrapWhitelistRequest
 */
export interface AddToBootstrapWhitelistRequest {
  /**
   * IP addresses to add to bootstrap whitelist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * AddToBootstrapWhitelistResponse holds the response from AddToBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.AddToBootstrapWhitelistResponse
 */
export interface AddToBootstrapWhitelistResponse {}
/**
 * AddToPeersWhitelistRequest holds the request for AddToPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.AddToPeersWhitelistRequest
 */
export interface AddToPeersWhitelistRequest {
  /**
   * IP addresses to add to peers whitelist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * AddToPeersWhitelistResponse holds the response from AddToPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.AddToPeersWhitelistResponse
 */
export interface AddToPeersWhitelistResponse {}
/**
 * AddStakingSecretKeysRequest holds the request for AddStakingSecretKeys
 *
 * @generated from protobuf message massa.api.v1.AddStakingSecretKeysRequest
 */
export interface AddStakingSecretKeysRequest {
  /**
   * Secret keys to add to wallet
   *
   * @generated from protobuf field: repeated string secret_keys = 1;
   */
  secretKeys: string[];
}
/**
 * AddStakingSecretKeysResponse holds the response from AddStakingSecretKeys
 *
 * @generated from protobuf message massa.api.v1.AddStakingSecretKeysResponse
 */
export interface AddStakingSecretKeysResponse {}
/**
 * AllowEveryoneToBootstrapRequest holds the request for AllowEveryoneToBootstrap
 *
 * @generated from protobuf message massa.api.v1.AllowEveryoneToBootstrapRequest
 */
export interface AllowEveryoneToBootstrapRequest {}
/**
 * AllowEveryoneToBootstrapResponse holds the response from AllowEveryoneToBootstrap
 *
 * @generated from protobuf message massa.api.v1.AllowEveryoneToBootstrapResponse
 */
export interface AllowEveryoneToBootstrapResponse {}
/**
 * GetBootstrapBlacklistRequest holds the request for GetBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.GetBootstrapBlacklistRequest
 */
export interface GetBootstrapBlacklistRequest {}
/**
 * GetBootstrapBlacklistResponse holds the response from GetBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.GetBootstrapBlacklistResponse
 */
export interface GetBootstrapBlacklistResponse {
  /**
   * Bootstrap blacklisted IP addresses
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * GetBootstrapWhitelistRequest holds the request for GetBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.GetBootstrapWhitelistRequest
 */
export interface GetBootstrapWhitelistRequest {}
/**
 * GetBootstrapWhitelistResponse holds the response from GetBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.GetBootstrapWhitelistResponse
 */
export interface GetBootstrapWhitelistResponse {
  /**
   * Bootstrap whitelisted IP addresses
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * GetMipStatusRequest holds request for GetMipStatus
 *
 * @generated from protobuf message massa.api.v1.GetMipStatusRequest
 */
export interface GetMipStatusRequest {}
/**
 * GetMipStatusResponse holds response from GetMipStatus
 *
 * @generated from protobuf message massa.api.v1.GetMipStatusResponse
 */
export interface GetMipStatusResponse {
  /**
   * (MipInfo - status id) entries
   *
   * @generated from protobuf field: repeated massa.model.v1.MipStatusEntry mipstatus_entries = 1;
   */
  mipstatusEntries: MipStatusEntry[];
}
/**
 * GetNodeStatusRequest holds the request for GetNodeStatus
 *
 * @generated from protobuf message massa.api.v1.GetNodeStatusRequest
 */
export interface GetNodeStatusRequest {}
/**
 * GetNodeStatusResponse holds the response from GetNodeStatus
 *
 * @generated from protobuf message massa.api.v1.GetNodeStatusResponse
 */
export interface GetNodeStatusResponse {
  /**
   * Node status
   *
   * @generated from protobuf field: massa.model.v1.NodeStatus status = 1;
   */
  status?: NodeStatus;
}
/**
 * GetPeersWhitelistRequest holds the request for GetPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.GetPeersWhitelistRequest
 */
export interface GetPeersWhitelistRequest {}
/**
 * GetPeersWhitelistResponse holds the response from GetPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.GetPeersWhitelistResponse
 */
export interface GetPeersWhitelistResponse {
  /**
   * Whitelisted IP addresses
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * BanNodesByIdsRequest holds the request for BanNodesByIds
 *
 * @generated from protobuf message massa.api.v1.BanNodesByIdsRequest
 */
export interface BanNodesByIdsRequest {
  /**
   * Node ids to ban
   *
   * @generated from protobuf field: repeated string node_ids = 1;
   */
  nodeIds: string[];
}
/**
 * BanNodesByIdsResponse holds the response from BanNodesByIds
 *
 * @generated from protobuf message massa.api.v1.BanNodesByIdsResponse
 */
export interface BanNodesByIdsResponse {}
/**
 * BanNodesByIpsRequest holds the request for BanNodesByIps
 *
 * @generated from protobuf message massa.api.v1.BanNodesByIpsRequest
 */
export interface BanNodesByIpsRequest {
  /**
   * Node IP addresses to ban
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * BanNodesByIpsResponse holds the response from BanNodesByIps
 *
 * @generated from protobuf message massa.api.v1.BanNodesByIpsResponse
 */
export interface BanNodesByIpsResponse {}
/**
 * RemoveFromBootstrapBlacklistRequest holds the request for RemoveFromBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromBootstrapBlacklistRequest
 */
export interface RemoveFromBootstrapBlacklistRequest {
  /**
   * IP addresses to remove from bootstrap blacklist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * RemoveFromBootstrapBlacklistResponse holds the response from RemoveFromBootstrapBlacklist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromBootstrapBlacklistResponse
 */
export interface RemoveFromBootstrapBlacklistResponse {}
/**
 * RemoveFromBootstrapWhitelistRequest holds the request for RemoveFromBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromBootstrapWhitelistRequest
 */
export interface RemoveFromBootstrapWhitelistRequest {
  /**
   * IP addresses to remove from bootstrap whitelist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * RemoveFromBootstrapWhitelistResponse holds the response from RemoveFromBootstrapWhitelist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromBootstrapWhitelistResponse
 */
export interface RemoveFromBootstrapWhitelistResponse {}
/**
 * RemoveFromPeersWhitelistRequest holds the request for RemoveFromPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromPeersWhitelistRequest
 */
export interface RemoveFromPeersWhitelistRequest {
  /**
   * IP addresses to remove from peers whitelist
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * RemoveFromPeersWhitelistResponse holds the response from RemoveFromPeersWhitelist
 *
 * @generated from protobuf message massa.api.v1.RemoveFromPeersWhitelistResponse
 */
export interface RemoveFromPeersWhitelistResponse {}
/**
 * RemoveStakingAddressesRequest holds the request for RemoveStakingAddresses
 *
 * @generated from protobuf message massa.api.v1.RemoveStakingAddressesRequest
 */
export interface RemoveStakingAddressesRequest {
  /**
   * Addresses to remove from staking
   *
   * @generated from protobuf field: repeated string addresses = 1;
   */
  addresses: string[];
}
/**
 * RemoveStakingAddressesResponse holds the response from RemoveStakingAddresses
 *
 * @generated from protobuf message massa.api.v1.RemoveStakingAddressesResponse
 */
export interface RemoveStakingAddressesResponse {}
/**
 * SignMessagesRequest holds the request for SignMessages
 *
 * @generated from protobuf message massa.api.v1.SignMessagesRequest
 */
export interface SignMessagesRequest {
  /**
   * Messages to sign in bytes
   *
   * @generated from protobuf field: repeated bytes messages = 1;
   */
  messages: Uint8Array[];
}
/**
 * SignMessagesResponse holds the response from SignMessages
 *
 * @generated from protobuf message massa.api.v1.SignMessagesResponse
 */
export interface SignMessagesResponse {
  /**
   * Public key that signed the message
   *
   * @generated from protobuf field: string public_key = 1;
   */
  publicKey: string;
  /**
   * Signatures
   *
   * @generated from protobuf field: repeated string signatures = 3;
   */
  signatures: string[];
}
/**
 * ShutdownGracefullyRequest holds the request for ShutdownGracefully
 *
 * @generated from protobuf message massa.api.v1.ShutdownGracefullyRequest
 */
export interface ShutdownGracefullyRequest {}
/**
 * ShutdownGracefullyResponse holds the response from ShutdownGracefully
 *
 * @generated from protobuf message massa.api.v1.ShutdownGracefullyResponse
 */
export interface ShutdownGracefullyResponse {}
/**
 * UnbanNodesByIdsRequest holds the request for UnbanNodesByIds
 *
 * @generated from protobuf message massa.api.v1.UnbanNodesByIdsRequest
 */
export interface UnbanNodesByIdsRequest {
  /**
   * Node ids to unban
   *
   * @generated from protobuf field: repeated string node_ids = 1;
   */
  nodeIds: string[];
}
/**
 * UnbanNodesByIdsResponse holds the response from UnbanNodesByIds
 *
 * @generated from protobuf message massa.api.v1.UnbanNodesByIdsResponse
 */
export interface UnbanNodesByIdsResponse {}
/**
 * UnbanNodesByIpsRequest holds the request for UnbanNodesByIps
 *
 * @generated from protobuf message massa.api.v1.UnbanNodesByIpsRequest
 */
export interface UnbanNodesByIpsRequest {
  /**
   * Nodes IP addresses to unban
   *
   * @generated from protobuf field: repeated string ips = 1;
   */
  ips: string[];
}
/**
 * UnbanNodesByIpsResponse holds the response from UnbanNodesByIps
 *
 * @generated from protobuf message massa.api.v1.UnbanNodesByIpsResponse
 */
export interface UnbanNodesByIpsResponse {}
// @generated message type with reflection information, may provide speed optimized methods
class AddToBootstrapBlacklistRequest$Type extends MessageType<AddToBootstrapBlacklistRequest> {
  constructor() {
    super('massa.api.v1.AddToBootstrapBlacklistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<AddToBootstrapBlacklistRequest>,
  ): AddToBootstrapBlacklistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToBootstrapBlacklistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToBootstrapBlacklistRequest,
  ): AddToBootstrapBlacklistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddToBootstrapBlacklistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToBootstrapBlacklistRequest
 */
export const AddToBootstrapBlacklistRequest =
  new AddToBootstrapBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddToBootstrapBlacklistResponse$Type extends MessageType<AddToBootstrapBlacklistResponse> {
  constructor() {
    super('massa.api.v1.AddToBootstrapBlacklistResponse', []);
  }
  create(
    value?: PartialMessage<AddToBootstrapBlacklistResponse>,
  ): AddToBootstrapBlacklistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToBootstrapBlacklistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToBootstrapBlacklistResponse,
  ): AddToBootstrapBlacklistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AddToBootstrapBlacklistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToBootstrapBlacklistResponse
 */
export const AddToBootstrapBlacklistResponse =
  new AddToBootstrapBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddToBootstrapWhitelistRequest$Type extends MessageType<AddToBootstrapWhitelistRequest> {
  constructor() {
    super('massa.api.v1.AddToBootstrapWhitelistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<AddToBootstrapWhitelistRequest>,
  ): AddToBootstrapWhitelistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToBootstrapWhitelistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToBootstrapWhitelistRequest,
  ): AddToBootstrapWhitelistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddToBootstrapWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToBootstrapWhitelistRequest
 */
export const AddToBootstrapWhitelistRequest =
  new AddToBootstrapWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddToBootstrapWhitelistResponse$Type extends MessageType<AddToBootstrapWhitelistResponse> {
  constructor() {
    super('massa.api.v1.AddToBootstrapWhitelistResponse', []);
  }
  create(
    value?: PartialMessage<AddToBootstrapWhitelistResponse>,
  ): AddToBootstrapWhitelistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToBootstrapWhitelistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToBootstrapWhitelistResponse,
  ): AddToBootstrapWhitelistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AddToBootstrapWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToBootstrapWhitelistResponse
 */
export const AddToBootstrapWhitelistResponse =
  new AddToBootstrapWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddToPeersWhitelistRequest$Type extends MessageType<AddToPeersWhitelistRequest> {
  constructor() {
    super('massa.api.v1.AddToPeersWhitelistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<AddToPeersWhitelistRequest>,
  ): AddToPeersWhitelistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToPeersWhitelistRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToPeersWhitelistRequest,
  ): AddToPeersWhitelistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddToPeersWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToPeersWhitelistRequest
 */
export const AddToPeersWhitelistRequest = new AddToPeersWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddToPeersWhitelistResponse$Type extends MessageType<AddToPeersWhitelistResponse> {
  constructor() {
    super('massa.api.v1.AddToPeersWhitelistResponse', []);
  }
  create(
    value?: PartialMessage<AddToPeersWhitelistResponse>,
  ): AddToPeersWhitelistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddToPeersWhitelistResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddToPeersWhitelistResponse,
  ): AddToPeersWhitelistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AddToPeersWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddToPeersWhitelistResponse
 */
export const AddToPeersWhitelistResponse =
  new AddToPeersWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddStakingSecretKeysRequest$Type extends MessageType<AddStakingSecretKeysRequest> {
  constructor() {
    super('massa.api.v1.AddStakingSecretKeysRequest', [
      {
        no: 1,
        name: 'secret_keys',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<AddStakingSecretKeysRequest>,
  ): AddStakingSecretKeysRequest {
    const message = { secretKeys: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddStakingSecretKeysRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddStakingSecretKeysRequest,
  ): AddStakingSecretKeysRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string secret_keys */ 1:
          message.secretKeys.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: AddStakingSecretKeysRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string secret_keys = 1; */
    for (let i = 0; i < message.secretKeys.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.secretKeys[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddStakingSecretKeysRequest
 */
export const AddStakingSecretKeysRequest =
  new AddStakingSecretKeysRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddStakingSecretKeysResponse$Type extends MessageType<AddStakingSecretKeysResponse> {
  constructor() {
    super('massa.api.v1.AddStakingSecretKeysResponse', []);
  }
  create(
    value?: PartialMessage<AddStakingSecretKeysResponse>,
  ): AddStakingSecretKeysResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AddStakingSecretKeysResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AddStakingSecretKeysResponse,
  ): AddStakingSecretKeysResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AddStakingSecretKeysResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AddStakingSecretKeysResponse
 */
export const AddStakingSecretKeysResponse =
  new AddStakingSecretKeysResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllowEveryoneToBootstrapRequest$Type extends MessageType<AllowEveryoneToBootstrapRequest> {
  constructor() {
    super('massa.api.v1.AllowEveryoneToBootstrapRequest', []);
  }
  create(
    value?: PartialMessage<AllowEveryoneToBootstrapRequest>,
  ): AllowEveryoneToBootstrapRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AllowEveryoneToBootstrapRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AllowEveryoneToBootstrapRequest,
  ): AllowEveryoneToBootstrapRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AllowEveryoneToBootstrapRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AllowEveryoneToBootstrapRequest
 */
export const AllowEveryoneToBootstrapRequest =
  new AllowEveryoneToBootstrapRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AllowEveryoneToBootstrapResponse$Type extends MessageType<AllowEveryoneToBootstrapResponse> {
  constructor() {
    super('massa.api.v1.AllowEveryoneToBootstrapResponse', []);
  }
  create(
    value?: PartialMessage<AllowEveryoneToBootstrapResponse>,
  ): AllowEveryoneToBootstrapResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<AllowEveryoneToBootstrapResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: AllowEveryoneToBootstrapResponse,
  ): AllowEveryoneToBootstrapResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: AllowEveryoneToBootstrapResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.AllowEveryoneToBootstrapResponse
 */
export const AllowEveryoneToBootstrapResponse =
  new AllowEveryoneToBootstrapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBootstrapBlacklistRequest$Type extends MessageType<GetBootstrapBlacklistRequest> {
  constructor() {
    super('massa.api.v1.GetBootstrapBlacklistRequest', []);
  }
  create(
    value?: PartialMessage<GetBootstrapBlacklistRequest>,
  ): GetBootstrapBlacklistRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetBootstrapBlacklistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetBootstrapBlacklistRequest,
  ): GetBootstrapBlacklistRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: GetBootstrapBlacklistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetBootstrapBlacklistRequest
 */
export const GetBootstrapBlacklistRequest =
  new GetBootstrapBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBootstrapBlacklistResponse$Type extends MessageType<GetBootstrapBlacklistResponse> {
  constructor() {
    super('massa.api.v1.GetBootstrapBlacklistResponse', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetBootstrapBlacklistResponse>,
  ): GetBootstrapBlacklistResponse {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetBootstrapBlacklistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetBootstrapBlacklistResponse,
  ): GetBootstrapBlacklistResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetBootstrapBlacklistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetBootstrapBlacklistResponse
 */
export const GetBootstrapBlacklistResponse =
  new GetBootstrapBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBootstrapWhitelistRequest$Type extends MessageType<GetBootstrapWhitelistRequest> {
  constructor() {
    super('massa.api.v1.GetBootstrapWhitelistRequest', []);
  }
  create(
    value?: PartialMessage<GetBootstrapWhitelistRequest>,
  ): GetBootstrapWhitelistRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetBootstrapWhitelistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetBootstrapWhitelistRequest,
  ): GetBootstrapWhitelistRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: GetBootstrapWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetBootstrapWhitelistRequest
 */
export const GetBootstrapWhitelistRequest =
  new GetBootstrapWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBootstrapWhitelistResponse$Type extends MessageType<GetBootstrapWhitelistResponse> {
  constructor() {
    super('massa.api.v1.GetBootstrapWhitelistResponse', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetBootstrapWhitelistResponse>,
  ): GetBootstrapWhitelistResponse {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetBootstrapWhitelistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetBootstrapWhitelistResponse,
  ): GetBootstrapWhitelistResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetBootstrapWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetBootstrapWhitelistResponse
 */
export const GetBootstrapWhitelistResponse =
  new GetBootstrapWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMipStatusRequest$Type extends MessageType<GetMipStatusRequest> {
  constructor() {
    super('massa.api.v1.GetMipStatusRequest', []);
  }
  create(value?: PartialMessage<GetMipStatusRequest>): GetMipStatusRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetMipStatusRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetMipStatusRequest,
  ): GetMipStatusRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: GetMipStatusRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetMipStatusRequest
 */
export const GetMipStatusRequest = new GetMipStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMipStatusResponse$Type extends MessageType<GetMipStatusResponse> {
  constructor() {
    super('massa.api.v1.GetMipStatusResponse', [
      {
        no: 1,
        name: 'mipstatus_entries',
        kind: 'message',
        repeat: 1 /* RepeatType.PACKED*/,
        T: () => MipStatusEntry,
      },
    ]);
  }
  create(value?: PartialMessage<GetMipStatusResponse>): GetMipStatusResponse {
    const message = { mipstatusEntries: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetMipStatusResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetMipStatusResponse,
  ): GetMipStatusResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated massa.model.v1.MipStatusEntry mipstatus_entries */ 1:
          message.mipstatusEntries.push(
            MipStatusEntry.internalBinaryRead(reader, reader.uint32(), options),
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetMipStatusResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated massa.model.v1.MipStatusEntry mipstatus_entries = 1; */
    for (let i = 0; i < message.mipstatusEntries.length; i++)
      MipStatusEntry.internalBinaryWrite(
        message.mipstatusEntries[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetMipStatusResponse
 */
export const GetMipStatusResponse = new GetMipStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeStatusRequest$Type extends MessageType<GetNodeStatusRequest> {
  constructor() {
    super('massa.api.v1.GetNodeStatusRequest', []);
  }
  create(value?: PartialMessage<GetNodeStatusRequest>): GetNodeStatusRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetNodeStatusRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetNodeStatusRequest,
  ): GetNodeStatusRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: GetNodeStatusRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetNodeStatusRequest
 */
export const GetNodeStatusRequest = new GetNodeStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetNodeStatusResponse$Type extends MessageType<GetNodeStatusResponse> {
  constructor() {
    super('massa.api.v1.GetNodeStatusResponse', [
      { no: 1, name: 'status', kind: 'message', T: () => NodeStatus },
    ]);
  }
  create(value?: PartialMessage<GetNodeStatusResponse>): GetNodeStatusResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetNodeStatusResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetNodeStatusResponse,
  ): GetNodeStatusResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* massa.model.v1.NodeStatus status */ 1:
          message.status = NodeStatus.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.status,
          );
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetNodeStatusResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* massa.model.v1.NodeStatus status = 1; */
    if (message.status)
      NodeStatus.internalBinaryWrite(
        message.status,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join();
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetNodeStatusResponse
 */
export const GetNodeStatusResponse = new GetNodeStatusResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeersWhitelistRequest$Type extends MessageType<GetPeersWhitelistRequest> {
  constructor() {
    super('massa.api.v1.GetPeersWhitelistRequest', []);
  }
  create(
    value?: PartialMessage<GetPeersWhitelistRequest>,
  ): GetPeersWhitelistRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetPeersWhitelistRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetPeersWhitelistRequest,
  ): GetPeersWhitelistRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: GetPeersWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetPeersWhitelistRequest
 */
export const GetPeersWhitelistRequest = new GetPeersWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPeersWhitelistResponse$Type extends MessageType<GetPeersWhitelistResponse> {
  constructor() {
    super('massa.api.v1.GetPeersWhitelistResponse', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<GetPeersWhitelistResponse>,
  ): GetPeersWhitelistResponse {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<GetPeersWhitelistResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: GetPeersWhitelistResponse,
  ): GetPeersWhitelistResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: GetPeersWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.GetPeersWhitelistResponse
 */
export const GetPeersWhitelistResponse = new GetPeersWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanNodesByIdsRequest$Type extends MessageType<BanNodesByIdsRequest> {
  constructor() {
    super('massa.api.v1.BanNodesByIdsRequest', [
      {
        no: 1,
        name: 'node_ids',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<BanNodesByIdsRequest>): BanNodesByIdsRequest {
    const message = { nodeIds: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<BanNodesByIdsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BanNodesByIdsRequest,
  ): BanNodesByIdsRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string node_ids */ 1:
          message.nodeIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BanNodesByIdsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string node_ids = 1; */
    for (let i = 0; i < message.nodeIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.nodeIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.BanNodesByIdsRequest
 */
export const BanNodesByIdsRequest = new BanNodesByIdsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanNodesByIdsResponse$Type extends MessageType<BanNodesByIdsResponse> {
  constructor() {
    super('massa.api.v1.BanNodesByIdsResponse', []);
  }
  create(value?: PartialMessage<BanNodesByIdsResponse>): BanNodesByIdsResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<BanNodesByIdsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BanNodesByIdsResponse,
  ): BanNodesByIdsResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: BanNodesByIdsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.BanNodesByIdsResponse
 */
export const BanNodesByIdsResponse = new BanNodesByIdsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanNodesByIpsRequest$Type extends MessageType<BanNodesByIpsRequest> {
  constructor() {
    super('massa.api.v1.BanNodesByIpsRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<BanNodesByIpsRequest>): BanNodesByIpsRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<BanNodesByIpsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BanNodesByIpsRequest,
  ): BanNodesByIpsRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: BanNodesByIpsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.BanNodesByIpsRequest
 */
export const BanNodesByIpsRequest = new BanNodesByIpsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BanNodesByIpsResponse$Type extends MessageType<BanNodesByIpsResponse> {
  constructor() {
    super('massa.api.v1.BanNodesByIpsResponse', []);
  }
  create(value?: PartialMessage<BanNodesByIpsResponse>): BanNodesByIpsResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<BanNodesByIpsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BanNodesByIpsResponse,
  ): BanNodesByIpsResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: BanNodesByIpsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.BanNodesByIpsResponse
 */
export const BanNodesByIpsResponse = new BanNodesByIpsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromBootstrapBlacklistRequest$Type extends MessageType<RemoveFromBootstrapBlacklistRequest> {
  constructor() {
    super('massa.api.v1.RemoveFromBootstrapBlacklistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<RemoveFromBootstrapBlacklistRequest>,
  ): RemoveFromBootstrapBlacklistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromBootstrapBlacklistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromBootstrapBlacklistRequest,
  ): RemoveFromBootstrapBlacklistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveFromBootstrapBlacklistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromBootstrapBlacklistRequest
 */
export const RemoveFromBootstrapBlacklistRequest =
  new RemoveFromBootstrapBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromBootstrapBlacklistResponse$Type extends MessageType<RemoveFromBootstrapBlacklistResponse> {
  constructor() {
    super('massa.api.v1.RemoveFromBootstrapBlacklistResponse', []);
  }
  create(
    value?: PartialMessage<RemoveFromBootstrapBlacklistResponse>,
  ): RemoveFromBootstrapBlacklistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromBootstrapBlacklistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromBootstrapBlacklistResponse,
  ): RemoveFromBootstrapBlacklistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: RemoveFromBootstrapBlacklistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromBootstrapBlacklistResponse
 */
export const RemoveFromBootstrapBlacklistResponse =
  new RemoveFromBootstrapBlacklistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromBootstrapWhitelistRequest$Type extends MessageType<RemoveFromBootstrapWhitelistRequest> {
  constructor() {
    super('massa.api.v1.RemoveFromBootstrapWhitelistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<RemoveFromBootstrapWhitelistRequest>,
  ): RemoveFromBootstrapWhitelistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromBootstrapWhitelistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromBootstrapWhitelistRequest,
  ): RemoveFromBootstrapWhitelistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveFromBootstrapWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromBootstrapWhitelistRequest
 */
export const RemoveFromBootstrapWhitelistRequest =
  new RemoveFromBootstrapWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromBootstrapWhitelistResponse$Type extends MessageType<RemoveFromBootstrapWhitelistResponse> {
  constructor() {
    super('massa.api.v1.RemoveFromBootstrapWhitelistResponse', []);
  }
  create(
    value?: PartialMessage<RemoveFromBootstrapWhitelistResponse>,
  ): RemoveFromBootstrapWhitelistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromBootstrapWhitelistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromBootstrapWhitelistResponse,
  ): RemoveFromBootstrapWhitelistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: RemoveFromBootstrapWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromBootstrapWhitelistResponse
 */
export const RemoveFromBootstrapWhitelistResponse =
  new RemoveFromBootstrapWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromPeersWhitelistRequest$Type extends MessageType<RemoveFromPeersWhitelistRequest> {
  constructor() {
    super('massa.api.v1.RemoveFromPeersWhitelistRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<RemoveFromPeersWhitelistRequest>,
  ): RemoveFromPeersWhitelistRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromPeersWhitelistRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromPeersWhitelistRequest,
  ): RemoveFromPeersWhitelistRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveFromPeersWhitelistRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromPeersWhitelistRequest
 */
export const RemoveFromPeersWhitelistRequest =
  new RemoveFromPeersWhitelistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFromPeersWhitelistResponse$Type extends MessageType<RemoveFromPeersWhitelistResponse> {
  constructor() {
    super('massa.api.v1.RemoveFromPeersWhitelistResponse', []);
  }
  create(
    value?: PartialMessage<RemoveFromPeersWhitelistResponse>,
  ): RemoveFromPeersWhitelistResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveFromPeersWhitelistResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveFromPeersWhitelistResponse,
  ): RemoveFromPeersWhitelistResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: RemoveFromPeersWhitelistResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveFromPeersWhitelistResponse
 */
export const RemoveFromPeersWhitelistResponse =
  new RemoveFromPeersWhitelistResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveStakingAddressesRequest$Type extends MessageType<RemoveStakingAddressesRequest> {
  constructor() {
    super('massa.api.v1.RemoveStakingAddressesRequest', [
      {
        no: 1,
        name: 'addresses',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<RemoveStakingAddressesRequest>,
  ): RemoveStakingAddressesRequest {
    const message = { addresses: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveStakingAddressesRequest>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveStakingAddressesRequest,
  ): RemoveStakingAddressesRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string addresses */ 1:
          message.addresses.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: RemoveStakingAddressesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string addresses = 1; */
    for (let i = 0; i < message.addresses.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.addresses[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveStakingAddressesRequest
 */
export const RemoveStakingAddressesRequest =
  new RemoveStakingAddressesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveStakingAddressesResponse$Type extends MessageType<RemoveStakingAddressesResponse> {
  constructor() {
    super('massa.api.v1.RemoveStakingAddressesResponse', []);
  }
  create(
    value?: PartialMessage<RemoveStakingAddressesResponse>,
  ): RemoveStakingAddressesResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<RemoveStakingAddressesResponse>(
        this,
        message,
        value,
      );
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: RemoveStakingAddressesResponse,
  ): RemoveStakingAddressesResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: RemoveStakingAddressesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.RemoveStakingAddressesResponse
 */
export const RemoveStakingAddressesResponse =
  new RemoveStakingAddressesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessagesRequest$Type extends MessageType<SignMessagesRequest> {
  constructor() {
    super('massa.api.v1.SignMessagesRequest', [
      {
        no: 1,
        name: 'messages',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 12 /* ScalarType.BYTES*/,
      },
    ]);
  }
  create(value?: PartialMessage<SignMessagesRequest>): SignMessagesRequest {
    const message = { messages: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SignMessagesRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SignMessagesRequest,
  ): SignMessagesRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated bytes messages */ 1:
          message.messages.push(reader.bytes());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SignMessagesRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated bytes messages = 1; */
    for (let i = 0; i < message.messages.length; i++)
      writer.tag(1, WireType.LengthDelimited).bytes(message.messages[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.SignMessagesRequest
 */
export const SignMessagesRequest = new SignMessagesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SignMessagesResponse$Type extends MessageType<SignMessagesResponse> {
  constructor() {
    super('massa.api.v1.SignMessagesResponse', [
      {
        no: 1,
        name: 'public_key',
        kind: 'scalar',
        T: 9 /* ScalarType.STRING*/,
      },
      {
        no: 3,
        name: 'signatures',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(value?: PartialMessage<SignMessagesResponse>): SignMessagesResponse {
    const message = { publicKey: '', signatures: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<SignMessagesResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SignMessagesResponse,
  ): SignMessagesResponse {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* string public_key */ 1:
          message.publicKey = reader.string();
          break;
        case /* repeated string signatures */ 3:
          message.signatures.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: SignMessagesResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string public_key = 1; */
    if (message.publicKey !== '')
      writer.tag(1, WireType.LengthDelimited).string(message.publicKey);
    /* repeated string signatures = 3; */
    for (let i = 0; i < message.signatures.length; i++)
      writer.tag(3, WireType.LengthDelimited).string(message.signatures[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.SignMessagesResponse
 */
export const SignMessagesResponse = new SignMessagesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownGracefullyRequest$Type extends MessageType<ShutdownGracefullyRequest> {
  constructor() {
    super('massa.api.v1.ShutdownGracefullyRequest', []);
  }
  create(
    value?: PartialMessage<ShutdownGracefullyRequest>,
  ): ShutdownGracefullyRequest {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ShutdownGracefullyRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ShutdownGracefullyRequest,
  ): ShutdownGracefullyRequest {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ShutdownGracefullyRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.ShutdownGracefullyRequest
 */
export const ShutdownGracefullyRequest = new ShutdownGracefullyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShutdownGracefullyResponse$Type extends MessageType<ShutdownGracefullyResponse> {
  constructor() {
    super('massa.api.v1.ShutdownGracefullyResponse', []);
  }
  create(
    value?: PartialMessage<ShutdownGracefullyResponse>,
  ): ShutdownGracefullyResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<ShutdownGracefullyResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: ShutdownGracefullyResponse,
  ): ShutdownGracefullyResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: ShutdownGracefullyResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.ShutdownGracefullyResponse
 */
export const ShutdownGracefullyResponse = new ShutdownGracefullyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnbanNodesByIdsRequest$Type extends MessageType<UnbanNodesByIdsRequest> {
  constructor() {
    super('massa.api.v1.UnbanNodesByIdsRequest', [
      {
        no: 1,
        name: 'node_ids',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<UnbanNodesByIdsRequest>,
  ): UnbanNodesByIdsRequest {
    const message = { nodeIds: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<UnbanNodesByIdsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UnbanNodesByIdsRequest,
  ): UnbanNodesByIdsRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string node_ids */ 1:
          message.nodeIds.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UnbanNodesByIdsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string node_ids = 1; */
    for (let i = 0; i < message.nodeIds.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.nodeIds[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.UnbanNodesByIdsRequest
 */
export const UnbanNodesByIdsRequest = new UnbanNodesByIdsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnbanNodesByIdsResponse$Type extends MessageType<UnbanNodesByIdsResponse> {
  constructor() {
    super('massa.api.v1.UnbanNodesByIdsResponse', []);
  }
  create(
    value?: PartialMessage<UnbanNodesByIdsResponse>,
  ): UnbanNodesByIdsResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<UnbanNodesByIdsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UnbanNodesByIdsResponse,
  ): UnbanNodesByIdsResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: UnbanNodesByIdsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.UnbanNodesByIdsResponse
 */
export const UnbanNodesByIdsResponse = new UnbanNodesByIdsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnbanNodesByIpsRequest$Type extends MessageType<UnbanNodesByIpsRequest> {
  constructor() {
    super('massa.api.v1.UnbanNodesByIpsRequest', [
      {
        no: 1,
        name: 'ips',
        kind: 'scalar',
        repeat: 2 /* RepeatType.UNPACKED*/,
        T: 9 /* ScalarType.STRING*/,
      },
    ]);
  }
  create(
    value?: PartialMessage<UnbanNodesByIpsRequest>,
  ): UnbanNodesByIpsRequest {
    const message = { ips: [] };
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<UnbanNodesByIpsRequest>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UnbanNodesByIpsRequest,
  ): UnbanNodesByIpsRequest {
    let message = target ?? this.create();
    let end = reader.pos + length;
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag();
      switch (fieldNo) {
        case /* repeated string ips */ 1:
          message.ips.push(reader.string());
          break;
        default:
          let u = options.readUnknownField;
          if (u === 'throw')
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            );
          let d = reader.skip(wireType);
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            );
      }
    }
    return message;
  }
  internalBinaryWrite(
    message: UnbanNodesByIpsRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string ips = 1; */
    for (let i = 0; i < message.ips.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.ips[i]);
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.UnbanNodesByIpsRequest
 */
export const UnbanNodesByIpsRequest = new UnbanNodesByIpsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnbanNodesByIpsResponse$Type extends MessageType<UnbanNodesByIpsResponse> {
  constructor() {
    super('massa.api.v1.UnbanNodesByIpsResponse', []);
  }
  create(
    value?: PartialMessage<UnbanNodesByIpsResponse>,
  ): UnbanNodesByIpsResponse {
    const message = {};
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    });
    if (value !== undefined)
      reflectionMergePartial<UnbanNodesByIpsResponse>(this, message, value);
    return message;
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: UnbanNodesByIpsResponse,
  ): UnbanNodesByIpsResponse {
    return target ?? this.create();
  }
  internalBinaryWrite(
    message: UnbanNodesByIpsResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields;
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      );
    return writer;
  }
}
/**
 * @generated MessageType for protobuf message massa.api.v1.UnbanNodesByIpsResponse
 */
export const UnbanNodesByIpsResponse = new UnbanNodesByIpsResponse$Type();
/**
 * @generated ServiceType for protobuf service massa.api.v1.PrivateService
 */
export const PrivateService = new ServiceType('massa.api.v1.PrivateService', [
  {
    name: 'AddToBootstrapBlacklist',
    options: {
      'google.api.http': { post: '/v1/add_to_boostrap_blacklist', body: '*' },
    },
    I: AddToBootstrapBlacklistRequest,
    O: AddToBootstrapBlacklistResponse,
  },
  {
    name: 'AddToBootstrapWhitelist',
    options: {
      'google.api.http': { post: '/v1/add_to_boostrap_whitelist', body: '*' },
    },
    I: AddToBootstrapWhitelistRequest,
    O: AddToBootstrapWhitelistResponse,
  },
  {
    name: 'AddToPeersWhitelist',
    options: {
      'google.api.http': { post: '/v1/add_to_peers_whitelist', body: '*' },
    },
    I: AddToPeersWhitelistRequest,
    O: AddToPeersWhitelistResponse,
  },
  {
    name: 'AddStakingSecretKeys',
    options: {
      'google.api.http': { post: '/v1/add_staking_secret_keys', body: '*' },
    },
    I: AddStakingSecretKeysRequest,
    O: AddStakingSecretKeysResponse,
  },
  {
    name: 'AllowEveryoneToBootstrap',
    options: {
      'google.api.http': { post: '/v1/allow_everyone_to_bootstrap', body: '*' },
    },
    I: AllowEveryoneToBootstrapRequest,
    O: AllowEveryoneToBootstrapResponse,
  },
  {
    name: 'GetBootstrapBlacklist',
    options: {
      'google.api.http': { post: '/v1/get_bootstrap_blacklist', body: '*' },
    },
    I: GetBootstrapBlacklistRequest,
    O: GetBootstrapBlacklistResponse,
  },
  {
    name: 'GetBootstrapWhitelist',
    options: {
      'google.api.http': { post: '/v1/get_bootstrap_whitelist', body: '*' },
    },
    I: GetBootstrapWhitelistRequest,
    O: GetBootstrapWhitelistResponse,
  },
  {
    name: 'GetMipStatus',
    options: { 'google.api.http': { post: '/v1/get_mip_status', body: '*' } },
    I: GetMipStatusRequest,
    O: GetMipStatusResponse,
  },
  {
    name: 'GetNodeStatus',
    options: { 'google.api.http': { post: '/v1/get_node_status', body: '*' } },
    I: GetNodeStatusRequest,
    O: GetNodeStatusResponse,
  },
  {
    name: 'GetPeersWhitelist',
    options: {
      'google.api.http': { post: '/v1/get_peers_whitelist', body: '*' },
    },
    I: GetPeersWhitelistRequest,
    O: GetPeersWhitelistResponse,
  },
  {
    name: 'BanNodesByIds',
    options: { 'google.api.http': { post: '/v1/ban_nodes_by_ids', body: '*' } },
    I: BanNodesByIdsRequest,
    O: BanNodesByIdsResponse,
  },
  {
    name: 'BanNodesByIps',
    options: { 'google.api.http': { post: '/v1/ban_nodes_by_ips', body: '*' } },
    I: BanNodesByIpsRequest,
    O: BanNodesByIpsResponse,
  },
  {
    name: 'RemoveFromBootstrapBlacklist',
    options: {
      'google.api.http': {
        post: '/v1/remove_from_bootstrap_blacklist',
        body: '*',
      },
    },
    I: RemoveFromBootstrapBlacklistRequest,
    O: RemoveFromBootstrapBlacklistResponse,
  },
  {
    name: 'RemoveFromBootstrapWhitelist',
    options: {
      'google.api.http': {
        post: '/v1/remove_from_bootstrap_whitelist',
        body: '*',
      },
    },
    I: RemoveFromBootstrapWhitelistRequest,
    O: RemoveFromBootstrapWhitelistResponse,
  },
  {
    name: 'RemoveFromPeersWhitelist',
    options: {
      'google.api.http': { post: '/v1/remove_from_peers_whitelist', body: '*' },
    },
    I: RemoveFromPeersWhitelistRequest,
    O: RemoveFromPeersWhitelistResponse,
  },
  {
    name: 'RemoveStakingAddresses',
    options: {
      'google.api.http': { post: '/v1/remove_staking_addresses', body: '*' },
    },
    I: RemoveStakingAddressesRequest,
    O: RemoveStakingAddressesResponse,
  },
  {
    name: 'SignMessages',
    options: { 'google.api.http': { post: '/v1/sign_messages', body: '*' } },
    I: SignMessagesRequest,
    O: SignMessagesResponse,
  },
  {
    name: 'ShutdownGracefully',
    options: {
      'google.api.http': { post: '/v1/shutdown_gracefully', body: '*' },
    },
    I: ShutdownGracefullyRequest,
    O: ShutdownGracefullyResponse,
  },
  {
    name: 'UnbanNodesByIds',
    options: {
      'google.api.http': { post: '/v1/unban_nodes_by_ids', body: '*' },
    },
    I: UnbanNodesByIdsRequest,
    O: UnbanNodesByIdsResponse,
  },
  {
    name: 'UnbanNodesByIps',
    options: {
      'google.api.http': { post: '/v1/unban_nodes_by_ips', body: '*' },
    },
    I: UnbanNodesByIpsRequest,
    O: UnbanNodesByIpsResponse,
  },
]);
